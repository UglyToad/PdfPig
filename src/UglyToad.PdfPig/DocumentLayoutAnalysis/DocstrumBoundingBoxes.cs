using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using UglyToad.PdfPig.Content;
using UglyToad.PdfPig.Geometry;
using UglyToad.PdfPig.Util;

namespace UglyToad.PdfPig.DocumentLayoutAnalysis
{
    /// <inheritdoc />
    /// <summary>
    /// The Document Spectrum (Docstrum) algorithm is a bottom-up page segmentation technique based on nearest-neighbourhood 
    /// clustering of connected components extracted from the document. 
    /// This implementation leverages bounding boxes and does not exactly replicates the original algorithm.
    /// <para>See 'The document spectrum for page layout analysis.' by L. O'Gorman.</para>
    /// </summary>
    public class DocstrumBoundingBoxes : IPageSegmenter
    {
        /// <summary>
        /// Create an instance of Docstrum for bounding boxes page segmenter, <see cref="DocstrumBoundingBoxes"/>.
        /// </summary>
        public static DocstrumBoundingBoxes Instance { get; } = new DocstrumBoundingBoxes();

        /// <inheritdoc />
        /// <summary>
        /// Get the blocks.
        /// <para>Uses wlAngleLB = -30, wlAngleUB = 30, blAngleLB = -135, blAngleUB = -45, blMulti = 1.3.</para>
        /// </summary>
        /// <param name="pageWords"></param>
        /// <returns></returns>
        public IReadOnlyList<TextBlock> GetBlocks(IEnumerable<Word> pageWords)
        {
            return GetBlocks(pageWords, new AngleBounds(-30, 30), new AngleBounds(-135, -45), 1.3);
        }

        /// <summary>
        /// Get the blocks. See original paper for more information.
        /// </summary>
        /// <param name="words">The words to segment into <see cref="TextBlock"/>s.</param>
        /// <param name="withinLine">Angle bounds for words to be considered on the same line.</param>
        /// <param name="betweenLine">Angle bounds for words to be considered on separate lines.</param>
        /// <param name="betweenLineMultiplier">Multiplier that gives the maximum perpendicular distance between 
        /// text lines for blocking. Maximum distance will be this number times the between-line 
        /// distance found by the analysis.</param>
        /// <returns>The <see cref="TextBlock"/>s generated by the document spectrum method.</returns>
        public IReadOnlyList<TextBlock> GetBlocks(IEnumerable<Word> words, AngleBounds withinLine,
            AngleBounds betweenLine,
            double betweenLineMultiplier)
        {
            if (words == null)
            {
                return EmptyArray<TextBlock>.Instance;
            }

            var wordsList = new List<Word>();

            foreach (var word in words)
            {
                if (string.IsNullOrWhiteSpace(word.Text))
                {
                    continue;
                }

                wordsList.Add(word);
            }

            if (wordsList.Count == 0)
            {
                return EmptyArray<TextBlock>.Instance;
            }

            var withinLineDistList = new ConcurrentBag<double>();
            var betweenLineDistList = new ConcurrentBag<double>();

            // 1. Estimate in line and between line spacing
            Parallel.For(0, wordsList.Count, i =>
            {
                var word = wordsList[i];

                // Within-line distance
                var pointsWithinLine = GetNearestPointDistance(wordsList, word,
                    bb => bb.BottomRight, bb => bb.BottomRight,
                    bb => bb.BottomLeft, bb => bb.BottomLeft,
                    withinLine, Distances.Horizontal);

                if (pointsWithinLine != null)
                {
                    withinLineDistList.Add(pointsWithinLine.Value);
                }

                // Between-line distance
                var pointsBetweenLine = GetNearestPointDistance(wordsList, word,
                    bb => bb.BottomLeft, bb => bb.Centroid,
                    bb => bb.TopLeft, bb => bb.Centroid,
                    betweenLine, Distances.Vertical);

                if (pointsBetweenLine != null)
                {
                    betweenLineDistList.Add(pointsBetweenLine.Value);
                }
            });

            double? withinLineDistance = GetPeakAverageDistance(withinLineDistList);
            double? betweenLineDistance = GetPeakAverageDistance(betweenLineDistList);

            if (withinLineDistance == null || betweenLineDistance == null)
            {
                return new[] {new TextBlock(new[] {new TextLine(wordsList)})};
            }

            // 2. Find lines of text
            double maxDistanceWithinLine = Math.Min(3 * withinLineDistance.Value, Math.Sqrt(2) * betweenLineDistance.Value);
            var lines = GetLines(wordsList, maxDistanceWithinLine, withinLine).ToArray();

            // 3. Find blocks of text
            double maxDistanceBetweenLine = betweenLineMultiplier * betweenLineDistance.Value;
            var blocks = GetLinesGroups(lines, maxDistanceBetweenLine).ToList();

            // 4. Merge overlapping blocks - might happen in certain conditions, e.g. justified text.
            for (var b = 0; b < blocks.Count; b++)
            {
                if (blocks[b] == null)
                {
                    continue;
                }

                // Merge all lines (words)
                blocks[b] = new TextBlock(GetLines(blocks[b].TextLines.SelectMany(l => l.Words).ToList(),
                    double.MaxValue, withinLine).ToList());

                for (var c = 0; c < blocks.Count; c++)
                {
                    if (b == c || blocks[c] == null)
                    {
                        continue;
                    }

                    if (blocks[b].BoundingBox.IntersectsWith(blocks[c].BoundingBox))
                    {
                        // Merge
                        // 1. Merge all words
                        var mergedWords = new List<Word>(blocks[b].TextLines.SelectMany(l => l.Words));
                        mergedWords.AddRange(blocks[c].TextLines.SelectMany(l => l.Words));

                        // 2. Rebuild lines, using max distance = +Inf as we know all words will be in the
                        // same block. Filtering will still be done based on angle.
                        // Merge all lines (words) sharing same bottom (baseline)
                        var mergedLines = GetLines(mergedWords, double.MaxValue, withinLine).ToList();
                        blocks[b] = new TextBlock(mergedLines.OrderByDescending(l => l.BoundingBox.Bottom).ToList());

                        // Remove
                        blocks[c] = null;
                    }
                }
            }

            return blocks.Where(b => b != null).ToList();
        }

        /// <summary>
        /// Get information on the nearest point, filtered for angle.
        /// </summary>
        private double? GetNearestPointDistance(List<Word> words, Word pivot, Func<PdfRectangle,
            PdfPoint> funcPivotDist, Func<PdfRectangle, PdfPoint> funcPivotAngle,
            Func<PdfRectangle, PdfPoint> funcPointsDist, Func<PdfRectangle, PdfPoint> funcPointsAngle,
            AngleBounds angleBounds,
            Func<PdfPoint, PdfPoint, double> finalDistanceMeasure)
        {
            var pointR = funcPivotDist(pivot.BoundingBox);

            var pivotPoint = funcPivotAngle(pivot.BoundingBox);

            var wordsWithinAngleBoundDistancePoints = new List<PdfPoint>();

            // Filter to words within the angle range.
            foreach (var word in words)
            {
                // Ignore the pivot word.
                if (ReferenceEquals(word, pivot))
                {
                    continue;
                }

                var angle = Distances.Angle(pivotPoint, funcPointsAngle(word.BoundingBox));

                if (angleBounds.Contains(angle))
                {
                    wordsWithinAngleBoundDistancePoints.Add(funcPointsDist(word.BoundingBox));
                }
            }

            if (wordsWithinAngleBoundDistancePoints.Count == 0)
            {
                return null;
            }

            var closestWordIndex = pointR.FindIndexNearest(wordsWithinAngleBoundDistancePoints, p => p,
                p => p, Distances.Euclidean, out _);

            if (closestWordIndex < 0 || closestWordIndex >= wordsWithinAngleBoundDistancePoints.Count)
            {
                return null;
            }

            return finalDistanceMeasure(pointR, wordsWithinAngleBoundDistancePoints[closestWordIndex]);
        }

        /// <summary>
        /// Build lines via transitive closure.
        /// </summary>
        private static IEnumerable<TextLine> GetLines(List<Word> words, double maxDist, AngleBounds withinLine)
        {
            TextDirection textDirection = words[0].TextDirection;
            var groupedIndexes = ClusteringAlgorithms.ClusterNearestNeighbours(words, Distances.Euclidean,
                (pivot, candidate) => maxDist,
                pivot => pivot.BoundingBox.BottomRight, candidate => candidate.BoundingBox.BottomLeft,
                pivot => true,
                (pivot, candidate) =>
                {
                    // Compare bottom right with bottom left for angle
                    var withinLineAngle = Distances.Angle(pivot.BoundingBox.BottomRight, candidate.BoundingBox.BottomLeft); 

                    return (withinLineAngle >= withinLine.Lower && withinLineAngle <= withinLine.Upper);
                }).ToList();

            Func<IEnumerable<Word>, IReadOnlyList<Word>> orderFunc = l => l.OrderBy(x => x.BoundingBox.Left).ToList();
            if (textDirection == TextDirection.Rotate180)
            {
                orderFunc = l => l.OrderByDescending(x => x.BoundingBox.Right).ToList();
            }
            else if (textDirection == TextDirection.Rotate90)
            {
                orderFunc = l => l.OrderByDescending(x => x.BoundingBox.Top).ToList();
            }
            else if (textDirection == TextDirection.Rotate270)
            {
                orderFunc = l => l.OrderBy(x => x.BoundingBox.Bottom).ToList();
            }

            for (var a = 0; a < groupedIndexes.Count; a++)
            {
                yield return new TextLine(orderFunc(groupedIndexes[a].Select(i => words[i])));
            }
        }

        /// <summary>
        /// Build blocks via transitive closure.
        /// </summary>
        private static IEnumerable<TextBlock> GetLinesGroups(TextLine[] lines, double maxDist)
        {
            /**************************************************************************************************
             * We want to measure the distance between two lines using the following method:
             *  We check if two lines are overlapping horizontally.
             *  If they are overlapping, we compute the middle point (new X coordinate) of the overlapping area.
             *  We finally compute the Euclidean distance between these two middle points.
             *  If the two lines are not overlapping, the distance is set to the max distance.
             **************************************************************************************************/

            Func<PdfLine, PdfLine, double> euclidianOverlappingMiddleDistance = (l1, l2) =>
            {
                var left = Math.Max(l1.Point1.X, l2.Point1.X);
                var d = (Math.Min(l1.Point2.X, l2.Point2.X) - left);

                if (d < 0) return double.MaxValue; // not overlapping -> max distance

                return Distances.Euclidean(
            new PdfPoint(left + d / 2, l1.Point1.Y),
            new PdfPoint(left + d / 2, l2.Point1.Y));
            };

            var groupedIndexes = ClusteringAlgorithms.ClusterNearestNeighbours(lines,
                euclidianOverlappingMiddleDistance,
                (pivot, candidate) => maxDist,
                pivot => new PdfLine(pivot.BoundingBox.BottomLeft, pivot.BoundingBox.BottomRight),
                candidate => new PdfLine(candidate.BoundingBox.TopLeft, candidate.BoundingBox.TopRight),
                pivot => true, (pivot, candidate) => true).ToList();

            for (int a = 0; a < groupedIndexes.Count(); a++)
            {
                yield return new TextBlock(groupedIndexes[a].Select(i => lines[i]).ToList());
            }
        }
        
        /// <summary>
        /// Get the average distance value of the peak bucket of the histogram.
        /// </summary>
        /// <param name="distances">The set of distances to average.</param>
        private static double? GetPeakAverageDistance(IEnumerable<double> distances)
        {
            var buckets = new Dictionary<int, List<double>>();
            foreach (var distance in distances)
            {
                var floor = (int)distance;

                if (buckets.ContainsKey(floor))
                {
                    buckets[floor].Add(distance);
                }
                else
                {
                    buckets[floor] = new List<double> {distance};
                }
            }

            var best = default(List<double>);

            foreach (var bucket in buckets)
            {
                if (best == null  || bucket.Value.Count > best.Count)
                {
                    best = bucket.Value;
                }
            }

            return best?.Average();
        }

        /// <summary>
        /// The bounds for the angle between two words for them to have a certain type of relationship.
        /// </summary>
        public struct AngleBounds
        {
            /// <summary>
            /// The lower bound in degrees.
            /// </summary>
            public double Lower { get; }

            /// <summary>
            /// The upper bound in degrees.
            /// </summary>
            public double Upper { get; }

            /// <summary>
            /// Create a new <see cref="AngleBounds"/>.
            /// </summary>
            public AngleBounds(double lowerBound, double upperBound)
            {
                Lower = lowerBound;
                Upper = upperBound;
            }

            /// <summary>
            /// Whether the bounds contain the angle.
            /// </summary>
            public bool Contains(double angle)
            {
                return angle >= Lower && angle <= Upper;
            }
        }
    }
}
